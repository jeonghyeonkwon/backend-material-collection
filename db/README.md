# 실무용 DB, SQL 관련

## DB LOCK

- 데이터 베이스의 접근 권한을 막는 것
- 동시에 접근하려고 할 때 일관성이 깨진다.
  - 1개 수량이 남은 물건을 2명의 소비자가 동시에 조회하면 1개 수량이기 때문에 구매 가능하게 된다.
  - 3000원 계좌에 동시에 조회하면 3000원이고 2명의 사용자가 500원, 1000원 각각 입금하게 되면 4500원이 되지 않는다
- 벤더 사 마다 조금씩 Lock 종류와 전략들이 다르다

### Optimistic(낙관적인) Lock

- 기본적으로 충돌이 발생하지 않을 것이라 보고 우선 락을 걸지 않는다.
- 동시에 조회하면 둘 다 1인 version에 커밋할 시 +1로 verion을 올려 준다. 그때 뒤에 커밋한 것에 에러를 터트린다. 버전이 달라졌으므로
- db에서 하는 것이 아닌 application에서 거는 락

### Pessimistic(비관적인) Lock

- 미리 충돌날 것이라 보고 조회 할 때부터 db에 락을 검
- 한 명이 가지고 오면 다른 한 사람은 대기 해야 됨
- 데드락의 위험성
- 종류
  - Shared Lock : 읽을 수는 있지만 UPDATE, DELETE 방지
  - Exclusive Lock : 읽기, 수정, 삭제 모두 방지

### 데드락

- 락으로 인해 발생
- 트랜잭션 1이 A를 락 B를 조회, 트랜잭션 2가 B를 락 A를 조회 하면 발생(A와 B는 각각 1개의 행)

### 참고 자료

[유튜브 - [10분 테코톡] 🍧카일의 데이터베이스 락](https://www.youtube.com/watch?v=w6sFR3ZM64c&t=306s)

## DB 격리 수준

- 오라클은 기본 READ-COMMITTED MY-SQL은 REPEATABLE-READ

* Read Uncomitted

  - 사용 하지 않음
  - 커밋 전에 값만 수정해도 다른 트랜잭션이 조회하면 바뀐 값이 출력된다.

* Read Committed

  - 커밋된 데이터만 읽기
    - 커밋된 값과 트랜잭션 진행 중인 값을 따로 보관
  - 커밋된 데이터만 덮어쓰기
    - 행 단위 잠금 사용
      - 같은 데이터를 수정한 트랜잭션이 끝날때 까지 대기

* Repeatable Read
  - 트랜잭션 동안 같은 데이터를 읽게 함
    - 읽는 시점에 특정 버전에 해당하는 데이터만 읽음

- Serializable

  - 인덱스 잠금이나 조건 기반 잠금 등 사용
    - 업데이트가 일어나고 커밋되기 전까지 다른 update에 대한 것은 다 거부

## 격리수준에 따른 문제

| 격리 수준        | Dirty READ | NONE-REPEATABLE READ | PHANTOM READ |
| ---------------- | ---------- | -------------------- | ------------ |
| READ UNCOMMITTED | O          | O                    | O            |
| READ COMMITTED   |            | O                    | O            |
| REPEATABLE READ  |            |                      | O            |
| SERIALIZABLE     |            |                      |              |

### 커밋 되지 않는 데이터 읽기 ( Dirty Read )

- 기존 재고의 물품 1개에서 A 유저가 물품을 1개 더 추가 하고 갯수에 대한 것도 2로 수정할 때 그 사이에 B 유저가 조회하면 물품은 2개가 조회 되고 갯수에 대한 것은 1개로 조회 되는 것을 볼 수 있다
- 요약 : 트랜잭션1이 수정하고 commit 안해도 트랜잭션2가 수정한 데이터를 볼 수 있다.
  - 문제점
    - 트랜잭션 1이 롤백한다면?

### 반복 불가능한 읽기(NON-REPEATABLE READ)

- 트랜잭션 1이 유저A를 조회 중 트랜잭션 2가 유저A를 수정하고 커밋하면 트랜잭션 1이 다시 유저A를 조회하면 수정된 내용으로 조회 됨.
- 요약 : 트랜잭션 내에 같은 같은 데이터를 읽을 수 없음

### PHANTOM READ

- 트랜잭션1이 유저 리스트를 조회했을 때 10개의 레코드였는데 트랜잭션2가 유저를 추가 또는 삭제 하고 커밋하고 트랜잭션1이 다시 유저리스트를 조회 한다면 기존에 없던 레코드 추가나 없어진 레코드가 생긴다.

### 커밋 되지 않는 데이터 덮어쓰기 ( Dirty Write )

- 유저 A가 item1, item2의 소유자를 A로 순서대로 변경 사이에 유저 B가 item1, item2의 소유자를 B로 변경하면 item1의 소유자는 B item2의 소유자는 A가 된다.

### 읽는 동안 데이터 변경 (Read Skew)

- A, B 둘 다 포인트 10인 상황에서 유저1이 A와 B의 포인트 조회를 순서대로 실행 시 유저 1가 A, B 포인트를 +1 씩 올린다면 유저 1이 조회한 A와 B의 포인트는 각각 10 11이 된다

### 변경 유실 ( Lost Update )

- 유저1이 글을 조회하고 조회수 0 -> 1로 업데이트 하고 커밋 하기 전에 유저2가 같은 글을 조회하면 조회수는 0이고 조회수를 0에서 1로 업데이트 되기 때문에 2가 되지 않는 현상

#### 변경 유실에 대한 해결법

- 원자적 연산 방법 : UPDATE table SET readCnt = readCnt + 1 WHERE id = 1; 처럼 사용함 DB가 원자적 연산 지원하는지 확인 필요

- 명시적 잠금 : 조회하는 쿼리가 있을 시 다른 사람이 사용 중인 수정 쿼리를 끝날때 까지 대기 했다가 조회 허용하는 것

- CAS : 버전 값으로 수정하는 방식 유저 1이 조회 업데이트를 하는 사이 유저 2가 조회 업데이트를 하면 버전이 둘 다 1이다 하지만 둘 중 빠른 것이 버전을 2로 올리고 커밋 한다면 나머지 하나는 버전이 1이기 때문에 업데이트가 되지 않는다.

## information_schema

- MySQL에서는 서버에 있는 테이블, 컬럼, 인덱스 등 메타 데이터가 저장되어 있음
- 읽기만 가능하고 수정 불가능
- 이것을 이용해서 조회 시 성능에 문제가 되므로 정보만 확인하는 용도로만 사용해야 됨

## 성능 최적화

### 인덱스

- 조회 성능 - 디스크 I/O 줄이는게 핵심
- 인덱스를 사용하면 조회는 빨라져도 수정 삭제는 느려진다
  - 하지만 비율은 조회 비율이 몇 배는 더 많다(8:2, 9:1)
- group by, order by에서도 성능을 향상시킬 수 있음

### 인덱스 실행 계획

- ALL(full table scan)
  - 테이블 전체를 스캔할 때
  - 성능에 좋지 않음
  - 발생하는 이유
    - 인덱스가 없을 때
    - 데이터의 전체 갯수가 작을 때
    - 읽고자 하는 데이터가 전체의 25% 넘을 때
      - 옵티마이저가 인덱스를 사용하는 것 보다 전체를 읽는 것이 효율적이라 판단하기 때문에
- RANGE (index range sacn)
  - 범위 검색을 할 때 (17에서 ~ 29 까지)
  - 이상적으로 인덱스가 잘 걸렸을때
- INDEX
  - 인덱스 전체를 스캔
  - full table scan보다 성능이 좋고 index range scan 보다는 좋지 않음

### 인덱스 적용 사레

#### 기본 인덱스

- 어떤 컬럼 조회가 많이 발생하는지?
- 카디널리티가 높은 컬럼
  - 중복도가 낮은 컬럼 (아이디...)

#### 복합 인덱스

- 두개의 컬럼을 합쳐서 만드는 인덱스
- 결합 인덱스, 다중 컬럼 인덱스, composit index

#### 커버링 인덱스

- 인덱스 사용으로 처리하는 쿼리 중 가장 부화를 많이 차지 하는 부분
  - 찾은 인덱스의 pk들로 레코드를 읽을때
- 커버일 인덱스는

```sql
-- 전체를 조회한 것이 아닌
SELECT * FROM tbl WHERE ...
-- 인덱스로 설정한 컬럼만 조회하는 것으로 불필요한 것을 줄여 성능 향상
SELECT nickname, track FROM tbl WHERE ...
-- innoDB 특성상 pk를 복합 인덱스로 설정하지 않아도 pk를 주소로 가짐
```

#### 인덱스 컨디션 푸쉬다운

- extra 컬럼의 using where
  - innoDB 스토리지 엔진에서 테이블에서 행을 가져온 후 MySQL 엔진에서 추가적인 체크 조건을 활용해서 행의 범위를 축소 시키는 것
- extra 컬럼의 using index condition
  - 인덱스 컨디션 푸쉬 다운으로 인해 표시
  - 인덱스를 이용해서 테이블에서 행을 검색하는 경우의 최적화
  - MySQL의 최신 버전인 경우 활성화 되어 있음

### 정리 예정

- 인덱스 스킵 스캔
- 루스 인덱스 스캔
- 유니크 인덱스
- 전문 검색 인덱스
- 옵티 마이저
- ...

### 출처

- 도서 - 자바 ORM 표준 JPA 프로그래밍
- [유튜브 - 프로그래밍 초식 : DB 트랜잭션 조금 이해하기 02 격리](https://www.youtube.com/watch?v=poyjLx-LOEU&t=4s)
- [[10분 테코톡] 매트, 토르의 MySQL 성능 최적화 ](https://www.youtube.com/watch?v=nvnl9YgnON8&t=96s)
