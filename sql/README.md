# DB, SQL 관련

## 동시성 관련 문제

### 커밋 되지 않는 데이터 읽기 ( Dirty Read )

- 기존 재고의 물품 1개에서 A 유저가 물품을 1개 더 추가 하고 갯수에 대한 것도 2로 수정할 때 그 사이에 B 유저가 조회하면 물품은 2개가 조회 되고 갯수에 대한 것은 1개로 조회 되는 것을 볼수 있다

### 커밋 되지 않는 데이터 덮어쓰기 ( Dirty Write )

- 유저 A가 item1, item2의 소유자를 A로 순서대로 변경 사이에 유저 B가 item1, item2의 소유자를 B로 변경하면 item1의 소유자는 B item2의 소유자는 A가 된다.

### 읽는 동안 데이터 변경 (Read Skew)

- A, B 둘 다 포인트 10인 상황에서 유저1이 A와 B의 포인트 조회를 순서대로 실행 시 유저 1가 A, B 포인트를 +1 씩 올린다면 유저 1이 조회한 A와 B의 포인트는 각각 10 11이 된다

### 변경 유실 ( Lost Update )

- 유저1이 글을 조회하고 조회수 0 -> 1로 업데이트 하고 커밋 하기 전에 유저2가 같은 글을 조회하면 조회수는 0이고 조회수를 0 -> 업데이트 되기 때문에 2가 되지 않는 현상

#### 변경 유실에 대한 해결법

- 원자적 연산 방법 : UPDATE table SET readCnt = readCnt + 1 WHERE id = 1; 처럼 사용함 DB가 원자적 연산 지원하는지 확인 필요

- 명시적 잠금 : 조회하는 쿼리가 있을 시 다른 사람이 사용 중인 수정 쿼리를 끝날때 까지 대기 했다가 조회 허용하는 것

- CAS : 버전 값으로 수정하는 방식 유저 1이 조회 업데이트를 하는 사이 유저 2가 조회 업데이트를 하면 버전이 둘 다 1이다 하지만 둘 중 빠른 것이 버전을 2로 올리고 커밋 한다면 나머지 하나는 버전이 1이기 때문에 업데이트가 되지 않는다.

## DB 격리 수준

### Read Uncomitted

### Read Committed

- 커밋된 데이터만 읽기
  - 커밋된 값과 트랜잭션 진행 중인 값을 따로 보관
- 커밋된 데이터만 덮어쓰기
  - 행 단위 장금 사용
    - 같은 데이터를 수정한 트랜잭션이 끝날때 까지 대기

### Repeatable Read

- 트랜잭션 동안 같은 데이터를 읽게 함
  - 읽는 시점에 특정 버전에 해당하는 데이터만 읽음

### Serializable

- 인덱스 잠금이나 조건 기반 잠금 등 사용
  - 업데이트가 일어나고 커밋되기 전까지 다른 update에 대한 것은 다 거부

* 출처
  [https://www.youtube.com/watch?v=poyjLx-LOEU&t=4s](https://www.youtube.com/watch?v=poyjLx-LOEU&t=4s)
